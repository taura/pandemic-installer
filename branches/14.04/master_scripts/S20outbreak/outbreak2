#!/bin/bash
#
# outbreak2 : 
# a (hopefully) more robust command to copy the source
# disk to clients.
#
# usage:
#   ./outbreak2 [options] src_file dst_file
#
# try:
#    ./outbreak2 -h (or --help)
# and
#    ./outbreak2 --long_help
# for more details.
#
# make sure we do this at the beginning
# $_ is the path name with which this program
# is invoked. 
this_file=$_
cur_dir=$(pwd)
if [ "${this_file:0:1}" = "/" ]; then
    # this_file is an absolute path name
    this_file_abs=${this_file}
else
    # this_file is a relative path name
    this_file_abs=${cur_dir}/${this_file}
fi
this_dir=$(dirname ${this_file_abs})

# if we have this many clients, it never quits, no
# matter how many fractions of the clients have 
# failed (for example, if we set this 5, then
# the system never quits as long as you have 5
# clients).  use this value if you have a specific
# requirements about the number of clients you 
# make and do not care the success RATIO (e.g., 
# you start from 30 clients and do not care even
# if 25 failed and you get only 5).
# by default, set to a very large value
# so that it essentially has no effects.  whether
# the system keeps going or bails out is determined
# by the RELATIVE progress and failure RATE.
# (see continue_check below)
never_quit_above=100

#
# resume from the previous run using the check point
# file. by default, we don't use it (start from the
# beginning at each time). 
#
resume=0

#
# verify after writes (not implemented yet)
#
verify=0

#
# this command repeats invoking blkcpc to copy a 
# block of data.  blk_sz specifies the size of
# data copied per invocation of blkcpc.
#
blk_sz=$((64 * 2 ** 20))
pkt_sz=$((32 * 1024))

#
# timeout for transfering blk_sz bytes. 0 means
# it is calculated by blk_sz and an "normal" disk
# write speed (plus some margin). leave it to 0
# unless you know what it means.
#
timeout=0

#
# 1 if local test mode. when it is set, this command
# will do everything locally. it copies test_file_src
# in the current directory into test_file_dst of the
# clients (they move to their own temporary directories
# so it's safe for all of them to copy into test_file_dst).
#
#mode=local
mode=production

#
# when set by --disk_check option, do not transfer
# data and write junk data to disks
#
disk_check=0

#
# number of clients when mode=local
#
n_local_clients=4

#
# verbosity level
#
verbosity=1

#
# wallpaper is a misnomer. if set to 1, 
# a window pops up whosing the status 
# of each client
#
wallpaper=1

#
# fault injection probability.
# they are solely for debugging fault tolerant features.
# when read_fault>0.0, each read system call performed by
# blkcpc command fails with this probability. similarly for 
# send, recv, write, close, closesocket.  the behavior of 
# the injected fault is determined by block_on_fault.  
# when this is set, the process blocks (and does not exit)
# forever, until it is killed. this command handles this
# type of fault by giving --timeout option to gxpc that 
# invokes blkcpc. when block_on_fault is not set, then
# the process that experienced an injected fault immediately
# exits with status 1. 
#
read_fault=0.0
send_fault=0.0
recv_fault=0.0
write_fault=0.0
close_fault=0.0
closesocket_fault=0.0
block_on_fault=1

#
# run=0 for dryrun
# ask=1 to ask the user if it should go ahead
#
run=1
ask=1

#
# help
#
help=0
long_help=0

#
# brief usage
#
usage() {
    echo "USAGE:"
    echo "  $0 [options] [src] [dst]"
    echo ""
    echo "OPTIONS:"
    echo "  -h,--help"
    echo "  --long_help"
    echo "  --resume"
    echo "  --verify"
    echo "  --disk_check"
    echo "  --net_check"
    echo "  --no_wallpaper"
    echo "  --mode local/production [${mode}]"
    echo "  --verbosity 0-4 [${verbosity}]"
    echo "  --blk_sz N [${blk_sz}]"
    echo "  --pkt_sz N [${pkt_sz}]"
    echo "  --timeout S [${timeout}]"
    echo "  --never_quit_above [${never_quit_above}]"
    echo "  --read_fault p [${read_fault}]"
    echo "  --send_fault p [${send_fault}]"
    echo "  --recv_fault p [${recv_fault}]"
    echo "  --write_fault p [${write_fault}]"
    echo "  --close_fault p [${close_fault}]"
    echo "  --closesocket_fault p [${closesocket_fault}]"
    echo "  --block_on_fault 0/1 [${block_on_fault}]"
}

#
# long usage (still under construction)
#
long_usage() {
    cat <<EOF

DESCRIPTION:
  outbreak2 copies SRC on the local machine
into DST on client machines.  See EXAMPLES
section for some examples.  Without any
option, it will copy /dev/sda of the local
machine into /dev/sda of all client machines.
Client machines are listed in ping.mk in the
same directory of outbreak2 (${this_dir}).
By default, it is all machines having IP
addresses 10.0.3.100-10.0.3.199.

BASIC BEHAVIOR:

Since this command is primarily intended to
copy an entire drive typically hundreds of
giga bytes large, it has provisions for
gracefully handling faults.  Gracefully
handling faults in this context means two
things.

(i) When a client experiences a fault, other
healthy clients can continue; outbreak2
actually judges if it should continue with
remaining clients or stop the entire process
(bail out) with the following criterion;
basically, it bails out when so many clients
left so early.  The basic idea behind this is
when it happens, restarting from the
beginning won't lose too much work, so giving
the user a chance to add some more clients or
fix any problem that makes faults so common
will give a better harvest rate.  More
specifically, it continues when the following
is satisfied.

   fraction of remaining clients
 + fraction of already copied data > 0.9

When some errors occur, you can hopefully
just sit down and keep watching until it
finishes with the remaining clients or bails
out.  If it finishes, you'll get a fair
number of clients.  If it bails out and you
get no successful clients, it should be
because when so many clients have failed
pretty early, so restarting the process from
the beginning won't lose too much time.  You
also do not want to keep waiting for the
remaining clients to finish when the maximum
harvest you can expect is already low.  It
will also be likely that you want to examine
why so many faults happened and change the
set of clients or fix the network
connectivity anyway.

(ii) When the entire process bails out, you
can still resume from the point where the
first fault happens, with --resume option.
To this end, outbreak2 is writing the
progress to a checkpoint file (ckpt.db) in
the current directory.  When --resume option
is given, it reads the checkpoint file to
determine where it should start again.

During the operation, a window showing the
status will pop up on the desktop of each
client.  It shows hostname, IP address,
working directory, a globally unique ID (that
can be matched with text messages on the
local terminal), and the status (started,
succeeded, failed, bailed out).  As soon as a
client drops out due to a fault, the window
indicating the failure will show up on the
client.  

On the local terminal, various progress and
event messages will be shown.  They include:

 (a) How much progress has been made.  In
 general, all clients will progress in the
 same pace.  It repeats copying a block of
 the size defined by --blk_sz option to all
 the clients (default: 64MB).  Unless all
 clients are done with the block, no clients
 will go ahead.  So it keeps track of and
 shows the progress of all the clients with a
 single global value.

 (b) Clients that have failed, along with
 the error message they encounter, as long
 as they can deliver it back to the local 
 machine.
 

DISK COPY VS. FILE COPY:
Although its primary purpose is to copy an
entire disk, which is a special (device)
file, it can also be used to copy a regular
file.  You may simply give regular file names
as the source and destination files.  e.g.,
  ./outbreak2 big_file_src big_file_dst
or
  ./outbreak2 big_file 
the latter of which is equivalent to 
  ./outbreak2 big_file big_file 

This feature is mainly used for debugging and
testing this program (you don't want to copy
/dev/sda each time you test it, do you?).

Care must be taken how to interpret the
relative path name given as the destination
file.  A unique directory is created for each
client and it is used for the base path of
relative path names; thus, the relative
destination path becomes unique EVEN IF SOME
CLIENTS RUN on the same machine.

LOCAL TEST MODE: 
To facilitate debugging and testing, it has a
--mode=local option.  When --mode=local is
given, all clients run on the same machine.
See the description of --mode option below.

BEHAVIOR OF --RESUME OPTION:

All clients still participating basically
make an equal progress.  A single block of
the size specified by --blk_sz is sent and
written into all clients before any client
goes ahead.  Whenever a single block has been
written to all clients that are active at
that time, outbreak2 will record the fact to
a checkpoint file (ckpt.db), which is a
simple human-readable text file.  Each record
of the file looks like:

  addrs|path|mtime|size

ADDRS column is the list of IP addresses of
the client, as obtained by hostname -I
command (there may be multiple IP addresses).
PATH is the canonical absolute path name of
the destination file, as obtained by
os.path.realpath method of python module.
MTIME is the modification time of the
destination file as obtained by
os.stat(..).st_mtime.  SIZE is the number of
bytes that have been successfully written.

Whenever a single block of the size specified
by --blk_sz option has been successfully
written to all clients, outbreak2 will update
the corresponding records of the checkpoint
file.  In this process, the pair (addrs,
path) is used as a key.  In effect, it will
update MTIME and SIZE of still running
clients.  The record of a clients that
participated but has already dropped out due
to a fault won't be updated from the point
when it failed.  So, even if all
participating clients progress in an equal
pace, we may end up with different values in
the SIZE field among clients.

When outbreak2 is executed with --resume
option, it consults the checkpoint file and
matches clients that participate this time
with records in the checkpoint file.  For
each client, if the matching entry, whose
definition is given below, is found, it
assumes the first SIZE bytes has been written
to that client so can be skipped at this
time.  It may still be written if there are
other clients behind it (i.e., have smaller
SIZE values). It never happens that a single
byte range is written in some clients but not
in others unless there is a fault.

Note that we cannot make any assumption about
the identities and the states of the
participating machines across different
invocations of outbreak2 command.  It may be
the case the clients are partly replaced
between two successive invocations.  In fact,
it is quite common that physically different
machines are assigned the same IP address at
different invocations; physically different
disks are assigned the same path name (e.g.,
/dev/sda) at different invocations;
physically the same disk may be modified
between invocations.  To safely detect if a
client participating in the current
invocation of outbreak2 has a matching record
in the checkpoint file, it uses the triple
(addrs, path, mtime) as the key.  In other
words, if a client participating this time
has an IP address A, is going to write to a
file of absolute path P, and P's mtime is T,
it checks if a record satisfying ADDRS=A,
PATH=P, and MTIME=T exist in the checkpoint
file, and if so, it reads the SIZE column of
that record and assumes the first SIZE bytes
of the current client have already been
written and can be skipped.

OPTIONS:

  --resume : resumes from the point a failure
    occurred in the last invocation, rather than
    starting from the beginning of the file. See 
    BEHAVIOR OF --RESUME OPTION below for details.

  --verify : (not implemented yet) will
    verify the specified source file on the
    local machine is identical to the
    destination files on the client machines.

  --no_wallpaper : does not show status windows on 
    clients.  

  --mode local/production : --mode local can be
    used to locally test this program. when --mode
    local is given, it uses local processes as 
    clients.  The number of clients can be specified
    by --n_local_clients.  When this option is used,
    you cannot omit the source file name.  Also, 
    you probably do not want to use an absolute path 
    name for destination file name, as it will refer
    to the same file among all clients.  Take advantage
    of the fact that relative path names are relative
    to a directory unique to each client.  So, for 
    example, 
      ./outbreak2 --mode local foo bar
    is safe (bar becomes unique to each client).

  --verbosity V : controls the verbosity level. 

  --blk_sz N : determines the unit of work.

    outbreak2 repeatedly invokes blkcpc
    command (of GXP) to copy the file.  This
    option specifies how much data will be
    transferred on each invocation of blkcpc
    command.  As each invocation of blkcpc
    will open, seek, read/write, and close
    the source/destination files, giving too
    small a blk_sz value will result in large
    overhead.  On the other hand, outbreak2
    will show the progress and checkpoint it,
    you do not want to make it too large.

  --timeout S : specifies the timeout value
    of each blkcpc command.  The default
    value (0) means it is determined from the
    blk_sz value.

  --never_quit_above N : specifies the number
    of clients above which outbreak2 will
    never bail out.  Normally, outbreak2 will
    stop the entire process when it judges
    so many clients have failed so early that
    restarting the copy from scratch (perhaps
    with new machines or after fixing a problem
    that makes faults so common) won't lose too much
    time.  By specifying this value to a small
    value, you can guarantee outbreak2 won't give
    up as long as that many clients still remain.

  --read_fault p :
  --send_fault p : 
  --recv_fault p :
  --write_fault p :
  --close_fault p :
  --closesocket_fault p :

    specify the fault injection probability
    of the respective operation in blkcpc
    command.  --read_fault 1.0e-2 means any
    read system call will fail with
    probability 1.0e-2.

  --block_on_fault 0/1 : 1 means upon an
    injected fault, the blkcpc process will
    indefinitely block until outbreak2 killed
    them.


FILES:

ckpt.db : outbreak2 will create this file to
   record how much data were successfully
   copied to each client.  It is a
   |-separated text file containing IP
   addresses, absolute path to the
   destination file, the modification time,
   and the offset to which the copy
   succeeded.  when --resume option is given,
   outbreak2 consults this file to skip data
   that can be surely omitted.

/tmp/USER/outbreak/N : a working directory of
   client N, so that each client has a unique
   working directory even if some are running
   on the same machine.  Remember that a
   relative pathname given as the destination
   file is relative to this directory.

status.svg : the status file drawn on the
   desktop of each client.  It is created in
   one of the following directories (whichever
   exists).
   /home/USER/Desktop
   /home/USER/デスクトップ
   /tmp/USER/outbreak/N

status.pid : a file containing the pid of the
   process showing the status.svg.  The file
   is used to kill it when the status of the
   client changes to the process should be
   gone.  It is created in the same directory
   as status.svg

EXAMPLES:
(1) ./outbreak2 

copies /dev/sda of the local machine into
/dev/sda of all ping-reachable machines
having IP addresses 10.0.3.100-10.0.3.199.
Make sure the drive you want to copy is
/dev/sda.  The IP address range is hardwired
in ping.mk in this directory.  Modify ping.mk
when you want to change this behavior.

(2) ./outbreak2 /dev/sdb

ditto, but copies /dev/sdb instead of /dev/sda.
Use this when you know the drive you want to
copy is /dev/sdb.

(3) ./outbreak2 /dev/sdb /dev/sda

copies the /dev/sdb of the local machine to
/dev/sda of client machines.

(4) ./outbreak2 --resume 

resumes copying from the point where the
first fault occurred in the last run.  See
BEHAVIOR OF --RESUME OPTION above for
details.

(5) ./outbreak2 --mode local foo bar

copies FOO under the current directory to
/tmp/USER/outbreak/{0,1,2}/bar.  Non-existing
directories are created.

EOF
}

#
# prepare for command line parsing.
#    eval set -- xx yy zz ..
# sets the command line of this script to xx yy zz ..
#
# getopt ... command prints the "canonicalized" command line,
# so that command line processing becomes streamlined.
#
# together, eval set -- $(getopt ...)
# 
# will set the command line of this process that can be
# easily parsed.
#
eval set -- $(getopt -o "hnf" --long help,long_help,force,dryrun,resume,verify,disk_check,net_check,no_wallpaper,blk_sz:,pkt_sz:,timeout:,never_quit_above:,mode:,n_local_clients:,verbosity:,read_fault:,send_fault:,recv_fault:,write_fault:,close_fault:,closesocket_fault:,block_on_fault: -- "$@")

parse_args() {
    # the command line has been canonicalized, so we simply
    # loop over $1 $2 $3 $4 ... 
    while true ; do 
	case "$1" in
	    --help)
		help=1
		shift 1
		;;
	    -h)
		help=1
		shift 1
		;;
	    --long_help)
		long_help=1
		shift 1
		;;
	    -n)
		run=0
		shift 1
		;;
	    --dryrun)
		run=0
		shift 1
		;;
	    -f)
		ask=0
		shift 1
		;;
	    --force)
		ask=0
		shift 1
		;;
	    --resume)
		resume=1
		shift 1
		;;
	    --verify)
		verify=1
		shift 1
		;;
	    --disk_check)
		disk_check=1
		shift 1
		;;
	    --net_check)
		net_check=1
		shift 1
		;;
	    --no_wallpaper)
		wallpaper=0
		shift 1
		;;
	    --blk_sz)
		blk_sz="$2"
		shift 2
		;;
	    --pkt_sz)
		pkt_sz="$2"
		shift 2
		;;
	    --timeout)
		timeout="$2"
		shift 2
		;;
	    --never_quit_above)
		never_quit_above="$2"
		shift 2
		;;
	    --mode)
		mode="$2"
		shift 2
		;;
	    --n_local_clients)
		n_local_clients="$2"
		shift 2
		;;
	    --verbosity)
		verbosity="$2"
		shift 2
		;;
	    --read_fault)
		read_fault="$2"
		shift 2
		;;
	    --send_fault)
		send_fault="$2"
		shift 2
		;;
	    --recv_fault)
		recv_fault="$2"
		shift 2
		;;
	    --write_fault)
		write_fault="$2"
		shift 2
		;;
	    --close_fault)
		close_fault="$2"
		shift 2
		;;
	    --closesocket_fault)
		closesocket_fault="$2"
		shift 2
		;;
	    --block_on_fault)
		block_on_fault="$2"
		shift 2
		;;
	    --)
		shift 1
		break;
		;;
	    *)
		echo "outbreak: error: unknown option ($1)"
		return 1
		;;
	esac
    done

    # set the default timeout value.
    # assume a conservative estimate of the
    # (disk) bandwidth: 8MB.
    # plus 10 seconds margin.
    #
    if [ "${timeout}" = "0" ]; then
	# 8MB + 10 sec margin
	bw=$((8 * 1024 * 1024))
	timeout=$((${blk_sz} / ${bw} + 10))
    fi

    # determine source and destination file
    default_src=""
    if [ "${mode}" = "production" ]; then
	default_src=/dev/sda
    fi
    src_file=${1:-${default_src}}
    dst_file=${2:-${src_file}}
    if [ "${src_file}" = "" ]; then
	echo "outbreak: error: you should supply the source file when --mode=local"
	return 1
    fi
    if [ -b ${src_file} ]; then 
	# device file -> do not creat/trunc the destination file
	creat=0
	trunc=0
    else
	creat=1
	trunc=1
    fi

    # make src_file absolute, so that client 0 can find
    # it after changing to his temp dir.
    # ??? or should we avoid changing dir on client 0?

    # check point file that tracks how many bytes have been 
    # sucessfully copied
    ckpt_db="ckpt.db"
    return 0
}

print_args() {
    echo resume="${resume}"
    echo verify="${verify}"
    echo creat="${creat}"
    echo trunc="${trunc}"
    echo blk_sz="${blk_sz}"
    echo timeout="${timeout}"
    echo never_quit_above="${never_quit_above}"
    echo mode="${mode}"
    echo n_local_clients="${n_local_clients}"
    echo verbosity="${verbosity}"
    echo read_fault="${read_fault}"
    echo send_fault="${send_fault}"
    echo recv_fault="${recv_fault}"
    echo write_fault="${write_fault}"
    echo close_fault="${close_fault}"
    echo closesocket_fault="${closesocket_fault}"
    echo block_on_fault="${block_on_fault}"
    echo src_file="${src_file}"
    echo dst_file="${dst_file}"
}

#
# get_file_size FILE prints the size of FILE.
# open the file and seek the end of the file.
# I don't know if there is a convenient command
# for it; I resorted to python.
#

get_file_size() {
    if [ -e $1 ]; then
	python -c "import os,sys; print os.lseek(os.open(sys.argv[1], os.O_RDONLY), 0, os.SEEK_END)" $1
    else
	echo "error: file \"$1\" does not exist."
	return 1
    fi
}

#
# get clients that respond to ping, to know which
# clients we try to explore. (it used to explore
# all of them and get whichever clients we successfully
# explore, but this is too crude and looks ugly).
# we ping all clients in parallel.
# the trick is in ping.mk file in this directory.
#

get_pingable_clients() {
    ping_mk=${this_dir}/ping.mk
    make -s -f ${ping_mk} -j 
}

#
# clients, depending on it is a production run or local test
#
get_clients() {
    if [ "${mode}" = production ] ; then
	get_pingable_clients
    else 
	echo "client ${n_local_clients}"
    fi
}

#
# explore clients. make a temporary directory under
# /tmp/USER/outbreak/N, where USER is a user name and N is
# a unique index number (0,1,2, ...), and set their
# current directory there.
#
# the purpose of this is mainly to make this tool
# testable within a single node. by having them work
# on a separate directory, we can make the destination
# file unique for each client.
#

bring_up_clients_and_change_dir() {
    if [ "${mode}" = "production" ] ; then
	rsh_method=ssh
    else
	rsh_method=sh
    fi
    clients="$(get_clients)"
    if [ "${verbosity}" -ge 2 ] ; then
	echo "outbreak: clients: ${clients}"
    fi
    gxpc use ${rsh_method} $(hostname) .
    gxpc explore --timeout 15.0 --children_soft_limit 200 ${clients}

    gxpc -G ${src_gupid} export "OUTBREAK_CLIENT_IDX=\${GXP_EXEC_IDX}"

    gxpc -G ${src_gupid} e mkdir -p "/tmp/${USER}/outbreak/\${GXP_EXEC_IDX}"
    gxpc -G ${src_gupid} cd         "/tmp/${USER}/outbreak/\${GXP_EXEC_IDX}"
    if [ "${verbosity}" -ge 1 ] ; then
	echo "outbreak: source:"
	gxpc -g ${src_gupid} e echo "\"  \"\${GXP_GUPID} \$(pwd) ${src_file}"
	n_clients=$(gxpc -G ${src_gupid} ping | wc -l)
	echo "outbreak: ${n_clients} clients:"
	gxpc -G ${src_gupid} e echo "\"  \"\${GXP_GUPID} \$(pwd) ${dst_file}"
    fi
}

#
# check ckpt.sz file in the current directory of all
# clients. ckpt.sz file should have a single number
# indicating the offset it has done.
#

get_offset_from_checkpoint() {
    # sorry for the ugly command ...
    # for each client, obtain the |-separated triple 
    #    ADDRS|PATH|MTIME
    # and feed them to checkpoint.py program.
    # checkpoint.py min_offset ckpt.db prints a single
    # number indicating the offset to start copying 
    # from. For each input triple in ckpt.db, it looks
    # it up in the database.  If any triple is not found,
    # it immediately prints 0 and exits.  If all triples
    # are found, it prints the minimum of the values 
    # found in SIZE column of the database.
    gxpc -G ${src_gupid} e "echo \$(python -c 'import os,sys,stat; ip=sys.argv[1]; f=sys.argv[2]; print \"%s|%s|%f\" % (ip, os.path.realpath(f), os.stat(f).st_mtime)' \"\$(hostname -I)\" ${dst_file})" | ${this_dir}/checkpoint.py min_offset ${ckpt_db}
}

#
# set start_offset variable to where we should start this time.
# (1) unless --resume is given, we start from the beginning
# (2) if --resume is given, check checkpoint files
#

set_start_offset() {
    if [ "${resume}" = "0" ] ; then
	if [ "${verbosity}" -ge 1 ] ; then
	    echo "outbreak: --resume not given. ignore any checkpoint file"
	fi
	start_offset=0
    else
	if [ "${verbosity}" -ge 1 ] ; then
	    echo "outbreak: --resume is given,. use checkpoint file ${ckpt_db}"
	fi
	if [ "${verbosity}" -ge 2 ] ; then
	    cat ${ckpt_db}
	fi
	start_offset=$(get_offset_from_checkpoint)
    fi
    gxpc -G ${src_gupid} export outbreak_offset=${start_offset}
}


# a function that determines where we should
# keep going despite that some clients have failed,
# or we should bail out as too few clients are
# still alive. the conditions to keep going are
# (1) the source node has not failed
# (2) "enough" clients have not failed; here "enough"
#     means large enough compared to the progress
#     we have made so far.  for example, if a failure
#     occurs pretty early, it is likely to be good
#     to quit, as we do not lose too much by restarting
#     it from the beginning. on the other hand, if
#     we have copied 90% of the file, we probably should
#     keep going, even if there are only 30% of clients
#     left.

check_continue() {
    #ns=$1			# number of sources (0 or 1)
    #nc=$2			# number of clients still alive
    sz_done=$1 			# bytes that we have copied
    sz_total=$2			# bytes we need to copy in total
    n_clients=$3		# the original number of clients
    # never_quit_above=$6		# if the number of clients is this much,
    # we alywas contine

    ns=$(gxpc -g ${src_gupid} ping | wc -l)
    nc=$(gxpc -G ${src_gupid} ping | wc -l)

    if [ "${verbosity}" -ge 1 ]; then
	echo "outbreak: ${ns} source, ${nc}/${n_clients} clients, ${sz_done}/${sz_total} ($((${sz_done} * 100 / ${sz_total}))% done)" 
    fi

    # if the source has gone, no way to proceed
    if [ ${ns} -lt 1 ]; then
	echo "outbreak: the source failed. bail out."
	return 1
    fi

    # if the number of clients is larger than
    # the preset threshold, keep going
    if [ ${nc} -ge ${never_quit_above} ]; then
	return 0
    fi

    # otherwise, we determine if we continue or not
    # by the progress we have made and the number of
    # clients alive. the intuition is that, (a) if some
    # clients have died pretty early, we don't lose
    # too much by restarting it from scratch, possibly
    # after replacing failed clients with new ones.
    # (b) if we have made much progress (say 70%), then
    # we should be more patient.  to sum up (a) and (b),
    # we continue if :
    # 
    #  live clients      bytes we have copied 
    # ---------------- + ---------------------- > 0.9
    #  total clients        bytes in total
    #
    # here is an awkward expression to do this with integers
    # (better to do it in awk or something?)
    #
    if [ $((${sz_done} * ${n_clients} + ${nc} * ${sz_total})) -le $((${sz_total} * ${n_clients} * 9 / 10)) ] ; then
	echo "outbreak: too few clients are alive. bail out."
	return 1
    fi

    return 0			# OK, go ahead
}

# copy wall papers to everybody as a preparation.
# cur_dir is the directory in which this script is
# wallpaper_dir is the _relative_ path from their
# current directories (i.e., /tmp/USER/outbreak/N)
copy_stuff() {
    if [ "${verbosity}" -ge 1 ]; then
	echo "outbreak: copy change_status to clients with mw blkcpc"
    fi
    bcpv=$((${verbosity} - 1))
    # cp ${cur_dir}/change_status /tmp/
    n_clients=$(gxpc -G ${src_gupid} ping | wc -l)
    n_copy_ok=$(gxpc mw --master blkcpm blkcpc --verbosity ${bcpv} --creat 1 --trunc 1 ${cur_dir}/change_status ./cs | grep DONE | wc -l)
    if [ "${verbosity}" -ge 2 ]; then
	echo "copied to ${n_copy_ok} out of ${n_clients} clients"
    fi
    n_failed=$((${n_clients} - ${n_copy_ok}))
    if [ "${n_failed}" = 0 ]; then
	return 0
    else
	echo "failed to copy to some clients n_clients=${n_clients}, n_copy_ok=${n_copy_ok}"
	return 1
    fi
}

# 
# a fault tolerant :-) function to copy a block from the
# source to all clients. it uses blkcpm/blkcpc commands,
# now part of gxp3, to fetch a block and copy it to clients.
# we use time out (--timeout) of gxpc command, to continue
# despite failures (very slow disks, network disconnect, etc.). 
# after the command finishes, it examines if any client failed.
# if there is one, it examines reachability and disk health.
#

copy_block() {
    src_file=$1
    dst_file=$2
    a=$3			# from offset
    b=$4			# to offset

    # remember the set of clients still engaged.
    # this is necessary to change status on the
    # failed clients
    gxpc --timeout 3.0 ping > /dev/null
    gxpc savemask before

    if [ "${disk_check}" = 1 ] ; then
	do_trans=0
    else
	do_trans=1
    fi
    if [ "${net_check}" = 1 ] ; then
	do_write=0
    else
	do_write=1
    fi

    max_retries=2		# we try (max_retries + 1) times
    for i in $(seq 0 ${max_retries}); do
	if [ $i -gt 0 ] ; then
	    echo "outbreak: retry with reachable processes (try $i, max tries = ${max_retries})."
	    echo "outbreak: ping clients"
	fi
	# ping with timeout 3 sec
	n_ping_ok=$(gxpc --timeout 3.0 ping | wc -l)
	if [ $i -gt 0 ] ; then
	    echo "outbreak: ${n_ping_ok} processes (source or clients) responded"
	fi
	if [ "${n_ping_ok}" = "0" ]; then break ; fi
	# filter out unreachable guys
	gxpc smask
	if [ $i -gt 0 ] ; then
	    echo "outbreak: check disk writes"
	    n_disk_ok=$(gxpc --timeout ${timeout} mw --master blkcpm "blkcpc --pkt_sz ${pkt_sz} --creat ${creat} --trunc ${trunc} --read_fault ${read_fault} --send_fault ${send_fault} --recv_fault ${recv_fault} --write_fault ${write_fault} --close_fault ${close_fault} --closesocket_fault ${closesocket_fault} --block_on_fault ${block_on_fault} --min_receivers 0 --write 1 --transfer 0 --range ${a}:${b} ${src_file} ${dst_file}" | grep DONE | wc -l)
	    echo "outbreak: ${n_disk_ok} processes have OK disks"
	    if [ "${n_disk_ok}" = "0" ]; then break ; fi
	    gxpc smask
	fi
	# now copy a block, with timeout 10 sec.
	# blkcpc prints "OK" when done and we count the 
	# number of OK lines (TODO: should be made more robust)
	if [ "${verbosity}" -ge 1 ]; then
	    echo "outbreak: copy range ${a}:${b}"
	fi
	if [ "${verbosity}" -ge 2 ]; then
	    set -x
	fi

	n_copy_ok=$(gxpc --timeout ${timeout} mw --master blkcpm "blkcpc --pkt_sz ${pkt_sz} --creat ${creat} --trunc ${trunc} --read_fault ${read_fault} --send_fault ${send_fault} --recv_fault ${recv_fault} --write_fault ${write_fault} --close_fault ${close_fault} --closesocket_fault ${closesocket_fault} --block_on_fault ${block_on_fault} --min_receivers 0 --write ${do_write} --transfer ${do_trans} --range ${a}:${b} ${src_file} ${dst_file}" | grep DONE | wc -l)
	set +x

	n_failed=$((${n_ping_ok} - ${n_copy_ok} - 1))
	if [ "${n_failed}" = "0" ]; then
	    # echo "great, no processes failed. move on."
	    break
	else 
	    echo "outbreak: ${n_failed} processes failed."
	fi
    done
    # get the set of clients that have suceeded
    gxpc savemask after
    # update checkpoint files of those who have suceeded
    gxpc -G ${src_gupid} export outbreak_offset=${b}

    # modify checkpoint file
    gxpc -G ${src_gupid} e "echo \$(python -c 'import os,sys,stat; ip=sys.argv[1]; f=sys.argv[2]; print \"%s|%s|%f\" % (ip, os.path.realpath(f), os.stat(f).st_mtime)' \"\$(hostname -I)\" ${dst_file})" | ${this_dir}/checkpoint.py update ${ckpt_db} ${b}

    # now, try to change status of the guys who have failed this time.
    # to this end, we restore the set of clients who were engaged
    # before this turn.
    gxpc restoremask before
    # execute "change_status fail" when its ckpt.sz has an obsolete
    # value.
    gxpc -G ${src_gupid} --timeout 2.0 e "[ \${outbreak_offset} -lt ${b} ] && echo outbreak : \${GXP_GUPID} : \$(hostname) \(\$(hostname -I)\) drop out due to an error && ./cs fail"
    # we are all set. get back to the set that has succeeded
    gxpc restoremask after
}


main() {
    if ! parse_args $@; then 
	usage
	return 1
    fi
    if [ "${long_help}" = 1 ] ; then 
	usage
	long_usage
	return 0
    fi
    if [ "${help}" = 1 ] ; then 
	usage
	return 0
    fi
    if [ "${verbosity}" -ge 3 ] ; then 
	print_args
    fi

    # get the size of the source file/disk
    sz=$(get_file_size ${src_file})
    if [ "${sz}" = "" ]; then return 1; fi
    if [ "${verbosity}" -ge 2 ]; then
	echo "outbreak: src=${src_file}, dst=${dst_file}, size=${sz}."
    fi

    # clean up daemons left from the previous run
    gxpc quit

    # bring up the local daemon and get its name
    src_gupid=$(gxpc e echo '${GXP_GUPID}')
    if [ "${verbosity}" -ge 2 ] ; then
	echo "outbreak: source gupid = ${src_gupid}"
    fi

    # get the number of sources; it SHOULD BE one,
    # but we still check if the source has brought up
    n_sources=$(gxpc e hostname | wc -l) #  0 or 1

    # bring up clients and get the number of them.
    # they also go to their working dir
    bring_up_clients_and_change_dir
    
    # count the number of clients (source excluded with -G)
    n_clients=$(gxpc -G ${src_gupid} e hostname | wc -l)

    # if --resume is given, check checkpoint files
    # to determine the starting offset.
    # variable start_offset is set
    set_start_offset
    if [ "${verbosity}" -ge 1 ] ; then
	echo "outbreak: start from offset ${start_offset}"
    fi

    # dry run, if -n or --dryrun are given
    if [ "${run}" = 0 ] ; then exit 0; fi

    # ask if we should go ahead, unless -f or --force are given
    if [ "${ask}" = 1 ] ; then
	echo "should I go ahead [y/N]?" 1>&2
	reply=n
	read reply
	if [ "${reply}" != "y" ] ; then
	    echo "that's fine, see you later"
	    exit 0
	fi
    fi

    # copy the wallpaper changer and stuff to clients
    if [ "${wallpaper}" = 1 ]; then
	if ! copy_stuff ; then return 1; fi
	if [ "$(whoami)" = "root" ]; then
	    gxpc -G ${src_gupid} e sudo -u ubuntu sh -c '"DISPLAY=:0 xhost +"'    
	fi
    fi

    # change clients' wallpapers to the default one
    if [ "${wallpaper}" = 1 ]; then
	if [ "${verbosity}" -ge 1 ] ; then
	    echo "outbreak: reset client wallpapers to start"
	fi
	gxpc -G ${src_gupid} e ./cs start
    fi

    # keep track of time (+%s prints seconds since epoch)
    start_time=$(date +%s)

    a=${start_offset}
    # now the real work begins!
    while [ ${a} -lt ${sz} ]; do
	# show current time and seconds since start
	now=$(date +%s)
	sec_since_start=$((${now} - ${start_time}))
	echo "outbreak: $(date +%H:%M:%S) (${sec_since_start} sec since start)"
	# judge if we should continue or bail out
	if ! check_continue ${a} ${sz} ${n_clients}; then
	    if [ "${wallpaper}" = 1 ]; then
		gxpc -G ${src_gupid} --timeout 2.0 e ./cs bailout
	    fi
	    return 1		# NG
	fi
	# real work. copy bytes a..b of the file
	b=$((${a} + ${blk_sz}))
	copy_block ${src_file} ${dst_file} ${a} ${b} .
	a=${b}
    done
    # congrat. if you have gone thus far, you succeeded.
    # change wallpaper
    if [ "${verbosity}" -ge 1 ]; then
	echo "outbreak: set wallpaper to success"
    fi
    if [ "${wallpaper}" = 1 ]; then
	gxpc -G ${src_gupid} e ./cs success
    else
	gxpc -G ${src_gupid} ping > /dev/null
    fi
    gxpc smask
    echo "outbreak: ${nc} clients succeeded:"
    gxpc e echo "\$(hostname) \(\$(hostname -I)\) \${GXP_GUPID}"
}

main $@
